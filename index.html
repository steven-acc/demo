<!DOCTYPE html>
<html>

  <head>
    <title>Demo</title>
    <meta charset="UTF-8" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase.js"></script>
  </head>

  <body>
    <div></div>

    <script>
      class SimpleQueue {
        constructor(n) {
          this.n = n
          this.queue = []
        }
        enqueue(obj) {
          if (this.queue.length < this.n) {
            this.queue.push(obj)
          } else {
            this.dequeue()
            this.queue.push(obj)
          }
          return this
        }
        dequeue() {
          let first_element = this.queue.shift()
          return first_element
        }
      }

      class Particle2 {
        constructor(d, projection) {
          [this.x, this.y] = projection([d["ORIGIN_log"], d["ORIGIN_lat"]]);
          [this.dx, this.dy] = projection([d["DEST_log"], d["DEST_lat"]]);
          this.FL_date = d["FL_DATE"]
          this.angleRad = (() => {
            let radian = Math.atan2((this.dy - this.y), (this.dx - this.x));
            if (radian < 0) {
              radian += 2 * Math.PI;
            }
            return radian
          })()
          this.speed = 100;
          this.arrived = false;
          this.current_dist = 0
          this.curr_x = this.x;
          this.curr_y = this.y;
          this.origin = d["ORIGIN"];
          this.dest = d["DEST"];
          this.trail = new SimpleQueue(5);
          this.alpha = 1;
          this.final = Math.sqrt((this.dy - this.y) ** 2 + (this.dx - this.x) ** 2);
          this.start = null;
        }

        ease_func(t) {
          let animate_time = this.final / this.speed * 1000
          let time_frag = Math.min(t / animate_time, 1.0)
          let sqr = time_frag ** 2.5
          return sqr / (sqr + (1 - time_frag) ** 2.5)
        }

        distance(t) {
          t = t - this.start;
          let move = this.final * this.ease_func(t);

          if (this.current_dist >= this.final) {
            this.arrived = true;
            return this.final;
          } else {
            this.trail.enqueue({
              curr_x: this.curr_x,
              curr_y: this.curr_y
            });
            this.current_dist = move;
            this.update_location();
            return this.current_dist
          }
        }

        update_location() {
          if (this.arrived) return
          let deltaX = Math.cos(this.angleRad) * this.current_dist
          let deltaY = Math.sin(this.angleRad) * this.current_dist
          this.curr_x = this.x + deltaX
          this.curr_y = this.y + deltaY
          return this
        }

        draw(ctx, t) {
          if (this.arrived) return
          let tail_element = this.trail.queue[0]
          if (!this.start) this.start = t
          if (tail_element) {
            ctx.save()
            let grad = ctx.createLinearGradient(this.curr_x, this.curr_y, tail_element.curr_x, tail_element.curr_y);
            grad.addColorStop(0, 'rgba(72, 202, 228, 1.0)');
            grad.addColorStop(0.65, 'rgba(72, 202, 228, 0.0)');
            ctx.lineCap = "round";
            ctx.strokeStyle = grad;

            ctx.shadowColor = 'rgba(0, 150, 199, 0.8)';
            ctx.shadowBlur = 3;

            ctx.lineWidth = 1.8;
            ctx.beginPath();
            ctx.moveTo(this.curr_x, this.curr_y);
            ctx.lineTo(tail_element.curr_x, tail_element.curr_y);
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
          }
          ctx.save()
          ctx.beginPath();
          ctx.arc(this.curr_x, this.curr_y, 1.5, 0, Math.PI * 2, true);
          ctx.fillStyle = "rgba(0, 150, 199, " + this.alpha + ")";
          ctx.fill();
          ctx.closePath();
          ctx.restore();
          this.distance(t)
        }
      }

      let get_data = function(url) {
        return new Promise(function(resolve, rej) {
          var res = new XMLHttpRequest();
          res.open("get", url)
          res.onload = function(e) {
            resolve(res.response)
          }
          res.send()
        })
      }

      db = (() => {
        const flight = {
          apiKey: "AIzaSyBMVA42aQYMMGP1UnFUsgwJpAdPcNG9-HA",
          authDomain: "us-flight-f44c4.firebaseapp.com",
          projectId: "us-flight-f44c4",
        };
        var app = firebase.initializeApp(flight, "app");
        return firebase.firestore(app);
      })()
      let query = function() {
        let flight_collection = db.collection("flight");
        return new Promise((resolve, reject) => {
          flight_collection.get().then((querySnapshot) => {
            resolve(function*() {
              for (var doc of querySnapshot.docs) {
                yield doc;
              }
            })
          })
        })
      }

      let flight_iter = async () => {
        let result = await query();
        result = result()
        return () => {
          let {
            value,
            done
          } = result.next();
          if (done) return {
            data_id: 'done',
            loading_particles: []
          }
          let id = value.id;
          let flight = value.data();
          flight = Object.values(flight)
          return {
            data_id: id,
            loading_particles: flight
          }
        }
      }

      async function init() {
        const width = 800;
        const height = 600;
        let lastRun;
        let particles = [];
        let loading_particles = [];
        let particle_iterator, data_id;
        let animate_id = 0
        let rendering_particles = 200;


        let geoUS = await get_data("./us-states.json")
        geoUS = JSON.parse(geoUS)
        let airport_json = await get_data("./airport.json")
        airport_json = JSON.parse(airport_json)

        //initialize canvas and svg
        const div = d3.create("div")
          .style("position", "relative")
          .style("width", width + "px")
          .style("height", height + "px");

        const svg = div.append("svg")
          .style("background-image", 'url("./US_map.jpg")')
          .style("background-size", width * 0.983 + "px")
          .style("background-position", "top 39px left 25px")
          .style("background-repeat", "no-repeat")
          .style("width", width + "px")
          .style("height", height + "px");

        const canvas = div.append("canvas")
          .style("position", "absolute")
          .style("top", 0)
          .style("left", 0)
          .attr("width", width)
          .attr("height", height)
          .on("click", function(event) {
            window.cancelAnimationFrame(animate_id);
            let res = new XMLHttpRequest();
            res.open("get", "./airport_count_result.json")
            res.onload = function(e) {
              let airport_count_result = JSON.parse(res.response)
              context.clearRect(0, 0, width, height);
              airport_svg.selectAll("circle")
                .data(Object.values(airport_count_result), (d) => {
                  return d.ICAO
                })
                .transition()
                .duration(2000)
                .attr("r", function(d) {
                  return d.count * 0.08
                })
            }
            res.send()
          })

        const context = canvas.node().getContext("2d");

        const projection = d3.geoAlbersUsa().fitSize([width, height], geoUS)
        const path = d3.geoPath(projection);
        context.canvas.style.maxWidth = "100%";
        context.lineJoin = "round";
        context.lineCap = "round";

        //draw basemap
        svg.selectAll("path")
          .data(geoUS.features)
          .enter()
          .append("path")
          .attr("d", path)
          .style("stroke", "rgb(150, 150, 150)")
          .style("stroke-width", "0.8")
          .style("fill", "rgba(250, 250, 250, 0)");

        const airport_svg = svg.append("g");

        const svg_text = svg.append("text")
          .text("Demo (US flight data on 1-1-2021)")
          .attr("id", "svg_date_text")
          .attr("x", 20)
          .attr("y", 20)
        svg.append("text")
          .text("Click the canvas to stop animation")
          .attr("id", "svg_note_text")
          .attr("x", 20)
          .attr("y", 40)

        Object.values(airport_json).forEach((d) => {
          d.count = 1
        })

        airport_svg
          .selectAll("g")
          .data(Object.values(airport_json), (d) => {
            return d.ICAO
          })
          .enter()
          .append("circle")
          .attr("cx", function(d) {
            let [cx, cy] = projection([d["Longitude"], d["Latitude"]]);
            return cx
          })
          .attr("cy", function(d) {
            let [cx, cy] = projection([d["Longitude"], d["Latitude"]]);
            return cy
          })
          .attr("r", function(d) {
            return d.count * 0.08
          })
          .style("fill", "rgba(72, 202, 228, 0.35)")

        function drawAirport(svg, new_data) {
          const airport_update = svg.selectAll("circle")
            .data(Object.values(new_data), (d) => {
              return d.ICAO
            })
            .attr("r", function(d) {
              return d.count * 0.08
            })
          airport_update.exit().remove()
          airport_update
            .enter()
            .attr("r", function(d) {
              return d.count * 0.08
            })
        }

        particle_iterator = await flight_iter();
        ({data_id, loading_particles} = particle_iterator())        
        loading_particles.forEach((d) => {
          try {
            particles.push(new Particle2(d, projection))
          } catch (e) {
            return;
          }
        })
        loading_particles = null

        async function drawFrame(t) {

          if (!lastRun) {
            lastRun = t;
            animate_id = window.requestAnimationFrame(drawFrame);
            return
          }
          if ((t - lastRun) < 1000 / 30) {
            if (particles.length < rendering_particles * 1.5 && !loading_particles) {
              //load more data from firebase
              loading_particles = [];
              ({
                data_id,
                loading_particles
              } = particle_iterator())
              console.log(data_id);
              loading_particles.forEach((d) => {
                try {
                  particles.push(new Particle2(d, projection))
                } catch (e) {
                  return;
                }
              })
              loading_particles = null
            }
            //skip frame if > 30fps
            animate_id = window.requestAnimationFrame(drawFrame);
            return
          }

          context.clearRect(0, 0, width, height);
          particles = particles.filter((d, i) => {
            if (i <= rendering_particles) {
              d.draw(context, t);
            }
            if (d.arrived) {              
              airport_json[d.dest].count += 1;              
              drawAirport(airport_svg, airport_json)
            }
            return !d.arrived;
          }, this)

          if (particles.length != 0) {
            lastRun = t;

            animate_id = window.requestAnimationFrame(drawFrame);
          } else {
            window.cancelAnimationFrame(animate_id);
          }

        }
        drawFrame()

        document.body.appendChild(div.node())
      }
      init()

    </script>
  </body>

</html>
